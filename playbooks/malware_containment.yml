# ASIRA Malware Containment Playbook
# Version: 1.0.0
# Last updated: 2025-03-16 13:14:18
# Author: Mritunjay-mj

id: pb_malware_containment
name: Malware Containment
description: Isolate and contain malware infection on endpoints and servers
execution_mode: sequential
enabled: true
version: 1.0.0
created_at: 1742187258
updated_at: 1742187258
author: Mritunjay-mj

actions:
  - id: isolate_host
    type: containment
    description: Isolate the infected host from the network
    command: edpt_control --isolate {incident.hostname} --reason "Malware containment for incident {incident.id}"
    continue_on_failure: false
    timeout: 120
    parameters:
      allow_security_tools: true
      block_internet: true
      block_intranet: true
      keep_security_connection: true

  - id: scan_host
    type: command
    description: Run a full antivirus scan on the infected host
    command: edpt_control --scan {incident.hostname} --full --priority high
    continue_on_failure: true
    timeout: 600
    parameters:
      scan_type: full
      scan_priority: high
      upload_results: true
    output_variable: scan_results_path

  - id: collect_process_info
    type: enrichment
    description: Collect running processes and memory dump from the infected host
    command: edpt_forensic --processes {incident.hostname} --memory-dump --output {execution.id}_memory_dump
    continue_on_failure: true
    timeout: 300
    output_variable: memory_dump_path

  - id: collect_file_indicators
    type: enrichment
    description: Collect file hashes and indicators from the infected host
    command: edpt_forensic --files {incident.hostname} --hashes --output {execution.id}_file_indicators
    continue_on_failure: true
    timeout: 180
    output_variable: file_indicators_path

  - id: submit_to_sandbox
    type: api_call
    description: Submit suspicious files to sandbox for analysis
    api_endpoint: https://sandbox.example.com/api/submit
    api_method: POST
    api_headers:
      Authorization: "Bearer {credentials.sandbox_api_key}"
      Content-Type: "application/json"
    api_payload:
      hostname: "{incident.hostname}"
      incident_id: "{incident.id}"
      files_path: "{variables.file_indicators_path}"
      priority: "high"
    continue_on_failure: true
    timeout: 180
    output_variables:
      - analysis_id
      - results_file
      - report_url

  - id: wait_for_analysis
    type: wait
    description: Wait for sandbox analysis to complete
    condition: "{action_results.check_analysis_status.status == 'completed'}"
    interval: 30
    timeout: 900
    max_tries: 30
    action:
      id: check_analysis_status
      type: api_call
      description: Check sandbox analysis status
      api_endpoint: https://sandbox.example.com/api/analysis/{variables.analysis_id}/status
      api_method: GET
      api_headers:
        Authorization: "Bearer {credentials.sandbox_api_key}"
      output_variable: status

  - id: block_iocs
    type: command
    description: Block identified indicators of compromise across the environment
    script: |
      #!/bin/bash
      echo "Extracting and blocking IOCs from sandbox results"
      
      # Extract IOCs from sandbox results
      python3 /opt/asira/scripts/extract_iocs.py --input {variables.results_file} --output {execution.id}_iocs.txt
      
      # Count the number of IOCs
      IOC_COUNT=$(wc -l < {execution.id}_iocs.txt)
      echo "Found $IOC_COUNT indicators of compromise"
      
      # Block IOCs at the firewall and EDR levels
      edpt_control --block-iocs {execution.id}_iocs.txt --scope enterprise
      
      # Output the IOC count for use in notifications
      echo "::set-output ioc_count=$IOC_COUNT"
      echo "::set-output iocs_file={execution.id}_iocs.txt"
      
      # Return success
      exit 0
    continue_on_failure: true
    timeout: 300
    output_variables:
      - ioc_count
      - iocs_file

  - id: update_threat_intelligence
    type: api_call
    description: Update threat intelligence platform with new IOCs
    api_endpoint: https://ti.example.com/api/iocs/batch
    api_method: POST
    api_headers:
      Authorization: "Bearer {credentials.ti_api_key}"
      Content-Type: "application/json"
    api_payload:
      source: "ASIRA"
      confidence: "high"
      iocs_file: "{variables.iocs_file}"
      reference: "Incident {incident.id}"
      malware_name: "{incident.malware_name}"
      hostname: "{incident.hostname}"
      timestamp: "{execution.timestamp}"
    continue_on_failure: true
    timeout: 60
    output_variable: ti_update_id

  - id: identify_lateral_movement
    type: enrichment
    description: Identify potential lateral movement from the infected host
    command: edpt_forensic --network-connections {incident.hostname} --timeframe "48h" --output {execution.id}_connections
    continue_on_failure: true
    timeout: 180
    output_variable: connections_path

  - id: analyze_lateral_movement
    type: script
    description: Analyze network connections for potential lateral movement
    script: |
      #!/usr/bin/env python3
      import json
      import sys
      import os
      
      # Load connections data
      connections_path = "{variables.connections_path}"
      if not os.path.exists(connections_path):
          print("Connections file not found")
          sys.exit(1)
          
      with open(connections_path, 'r') as f:
          connections_data = json.load(f)
          
      # Identify internal connections
      internal_connections = []
      for conn in connections_data.get('connections', []):
          if conn.get('destination_ip').startswith(('10.', '172.16.', '192.168.')):
              internal_connections.append(conn)
              
      # Save results
      output_file = "{execution.id}_lateral_movement.json"
      with open(output_file, 'w') as f:
          json.dump({
              'internal_connections': internal_connections,
              'potential_lateral_movement': len(internal_connections) > 0,
              'connection_count': len(internal_connections)
          }, f, indent=2)
          
      print(f"Found {len(internal_connections)} potential internal lateral movement connections")
      print(f"Results saved to {output_file}")
      
      # Set output variables
      print(f"::set-output lateral_movement_detected={len(internal_connections) > 0}")
      print(f"::set-output connection_count={len(internal_connections)}")
      print(f"::set-output output_file={output_file}")
      
      sys.exit(0)
    continue_on_failure: true
    timeout: 120
    output_variables:
      - lateral_movement_detected
      - connection_count
      - output_file

  - id: quarantine_files
    type: command
    description: Quarantine detected malicious files
    command: edpt_control --quarantine-detected {incident.hostname}
    continue_on_failure: true
    timeout: 180

  - id: notify_security_team
    type: notification
    description: Notify security team about the malware containment actions
    template: malware_incident
    channels:
      - email
      - slack
      - sms
    parameters:
      severity: "{incident.severity}"
      hostname: "{incident.hostname}"
      incident_id: "{incident.id}"
      malware_name: "{incident.malware_name}"
      ioc_count: "{variables.ioc_count}"
      sandbox_report: "{variables.report_url}"
      scan_results: "{variables.scan_results_path}"
      lateral_movement: "{variables.lateral_movement_detected}"
      connection_count: "{variables.connection_count}"
    continue_on_failure: true
    timeout: 30

  - id: check_additional_hosts
    type: script
    description: Check for malware on additional hosts based on lateral movement
    condition: "{variables.lateral_movement_detected == true}"
    script: |
      #!/bin/bash
      echo "Checking additional hosts for malware infection based on lateral movement analysis"
      
      # Extract list of hosts to check
      python3 /opt/asira/scripts/extract_hosts.py --input "{variables.output_file}" --output "{execution.id}_hosts_to_check.txt"
      
      # Run quick scans on those hosts
      while read host; do
        echo "Running quick scan on $host"
        edpt_control --scan "$host" --quick --priority medium
      done < "{execution.id}_hosts_to_check.txt"
      
      echo "Additional host scans completed"
    continue_on_failure: true
    timeout: 600

tags:
  - malware
  - endpoint
  - containment
  - infection
  - ransomware

target_severity:
  - medium
  - high
  - critical

required_parameters:
  - hostname
  - severity
  - id
  - malware_name

cleanup_actions:
  - id: archive_forensic_data
    type: command
    description: Archive all collected forensic data
    command: |
      #!/bin/bash
      timestamp=$(date +%Y%m%d_%H%M%S)
      archive_dir="/var/log/asira/incidents/{incident.id}/forensics"
      
      mkdir -p "$archive_dir"
      
      # Archive memory dumps
      if [ -d "{variables.memory_dump_path}" ]; then
        cp -r "{variables.memory_dump_path}" "$archive_dir/memory_dump"
        echo "Memory dump archived to $archive_dir/memory_dump"
      fi
      
      # Archive file indicators
      if [ -f "{variables.file_indicators_path}" ]; then
        cp "{variables.file_indicators_path}" "$archive_dir/file_indicators.json"
        echo "File indicators archived to $archive_dir/file_indicators.json"
      fi
      
      # Archive IOCs
      if [ -f "{variables.iocs_file}" ]; then
        cp "{variables.iocs_file}" "$archive_dir/iocs.txt"
        echo "IOCs archived to $archive_dir/iocs.txt"
      fi
      
      # Archive lateral movement data
      if [ -f "{variables.output_file}" ]; then
        cp "{variables.output_file}" "$archive_dir/lateral_movement.json"
        echo "Lateral movement data archived to $archive_dir/lateral_movement.json"
      fi
      
      # Create manifest
      echo "Forensic data archive created on $timestamp for incident {incident.id}" > "$archive_dir/manifest.txt"
      echo "Hostname: {incident.hostname}" >> "$archive_dir/manifest.txt"
      echo "Malware: {incident.malware_name}" >> "$archive_dir/manifest.txt"
      
      echo "All forensic data archived to $archive_dir"
    timeout: 120

recovery_actions:
  - id: restore_network_access
    type: command
    description: Restore network access to the host after successful remediation
    command: edpt_control --deisolate {incident.hostname} --reason "Malware remediated for incident {incident.id}"
    timeout: 60
    parameters:
      verify_clean: true

  - id: validate_remediation
    type: command
    description: Validate that all malware has been remediated
    command: edpt_control --scan {incident.hostname} --quick --verify-clean
    timeout: 120

  - id: notify_remediation_complete
    type: notification
    description: Notify that remediation is complete
    template: remediation_complete
    channels:
      - email
      - slack
    parameters:
      hostname: "{incident.hostname}"
      incident_id: "{incident.id}"
      malware_name: "{incident.malware_name}"
      remediation_time: "{execution.duration}"
    timeout: 30

dependencies:
  - edpt_control: "2.0.0+"
  - edpt_forensic: "1.5.0+"
  - sandbox_api_access: "read-write"
  - threat_intelligence_api: "read-write"

documentation:
  detailed_description: |
    This playbook handles malware containment and analysis on an infected host.
    It performs the following actions:
    1. Network isolation to prevent lateral movement and data exfiltration
    2. Full antivirus scan to identify malware artifacts
    3. Forensic collection of process information and memory dumps
    4. File hash collection and submission to sandbox
    5. Extraction and enterprise-wide blocking of indicators of compromise
    6. Update of threat intelligence systems with new IOCs
    7. Analysis of potential lateral movement
    8. Notification to security teams with detailed information

  execution_notes: |
    - This playbook requires administrative access to the endpoint protection platform
    - Sandbox analysis may take several minutes to complete
    - For large enterprises, blocking IOCs across the environment may take time
    - The playbook will automatically check for lateral movement and scan additional hosts if detected

  recovery_notes: |
    After malware has been successfully removed:
    1. Run the validation scan to verify the host is clean
    2. Run the restore network access action to bring the host back online
    3. Monitor the host for 24-48 hours for any signs of reinfection

risk_assessment:
  disruption_impact: "Medium to High - Host will be isolated from the network"
  false_positive_impact: "Medium - May unnecessarily isolate a critical system"
  recommended_approvals:
    - security_team_lead
    - it_manager

metrics:
  - name: time_to_containment
    description: Time from incident detection to host isolation
    calculation: "action_results.isolate_host.end_time - execution.start_time"
  
  - name: ioc_detection_count
    description: Number of IOCs identified and blocked
    calculation: "variables.ioc_count"
  
  - name: lateral_movement_detection
    description: Whether lateral movement was detected
    calculation: "variables.lateral_movement_detected"
